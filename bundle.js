/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ 29:
/***/ ((__unused_webpack_module, __unused_webpack___webpack_exports__, __webpack_require__) => {

eval("\n;// ./sample/comic/124412124.zip\n/* harmony default export */ const _124412124 = (__webpack_require__.p + \"124412124.zip\");\n;// ./sample/epub/childrens-literature.epub\n/* harmony default export */ const childrens_literature = (__webpack_require__.p + \"childrens-literature.epub\");\n;// ./sample/pdf/sample2.pdf\n/* harmony default export */ const sample2 = (__webpack_require__.p + \"sample2.pdf\");\n;// ./src/viewer/common.js\n\n\n\n\n\n/**\n * @callback EventHandler\n * @param {Event} event - The event object passed to the handler function.\n */\n\n/**\n * @typedef {Object} EventBus 상품등록타입\n * @param {HTMLElement} element 엘리먼트\n * @param {string} event 이벤트\n * @param {EventHandler} handler 콜백\n */\n\n/**\n * @typedef ExtractZip 추출한 Zip 객체\n * @param {Object} zip Zip 객체\n * @param {Array<>} paths 경로 array\n */\n\nfunction onDocumentReady() {\n  // Your callback code here\n  window.Viewerer = Viewer();\n}\n\nif (document.readyState === 'complete') {\n  onDocumentReady(); // If the document is already loaded, call the callback directly\n} else {\n  document.addEventListener('DOMContentLoaded', onDocumentReady); // Otherwise, wait for the event\n}\n\n/**\n * Adds an event listener to an element and prevents event propagation.\n *\n * @param {HTMLElement|NodeList} element - The target element to which the event listener is attached.\n * @param {string} event - The type of the event (e.g., 'click', 'keydown').\n * @param {EventHandler} handler - The function to execute when the event is triggered.\n */\nfunction addEventListenerRegist(element, event, handler) {\n  if (!element) {\n    return;\n  }\n  if (element instanceof NodeList || Array.isArray(element)) {\n    element.forEach(element2 => {\n      element2.addEventListener(event, e => {\n        e.stopPropagation();\n        handler(e);\n      });\n    });\n    return;\n  }\n  element.addEventListener(event, e => {\n    e.stopPropagation();\n    handler(e);\n  });\n}\n// console.log('##process.env.VIEWER_ENV', process.env.isProduction);\n/**\n * 디버깅여부\n */\nconst IS_DEBUG = !true;\n\n/**\n * Viewer 객체\n * @returns\n */\nconst Viewer = function () {\n  const INSTANCE = {};\n  /**\n   * @enum {string}\n   */\n  const PageMode = {\n    SINGLE: 'single',\n    DUAL: 'dual',\n    FIRST_DUAL: 'firstdual',\n    SCROLL: 'scroll',\n  };\n\n  /**\n   * @enum {string}\n   */\n  const FileType = {\n    EPUB: 'epub',\n    PDF: 'pdf',\n    COMIC: 'comic',\n  };\n  /** for viewer */\n  const viewerDiv = document.getElementById('viewer');\n\n  let timer = null;\n  window.addEventListener('resize', () => {\n    viewerContainer.style.visibility = 'hidden';\n    View.resizeAll();\n    if (fileType != FileType.EPUB) {\n      Navi.gotoPage(currentFileNo);\n    }\n\n    if (timer) {\n      clearTimeout(timer);\n      timer = null;\n    }\n    timer = setTimeout(() => {\n      View.setPageMode(currentPageMode, true);\n      Navi.gotoPage(currentFileNo);\n      viewerContainer.style.visibility = 'visible';\n      clearTimeout(timer);\n      timer = null;\n    }, 300);\n  });\n\n  /** @type {HTMLElement} */\n  let viewerContainer;\n\n  /** UI */\n  const tabButtons = document.querySelectorAll('.tab-button');\n  const panels = document.querySelectorAll('.tab-panel');\n  const sideBar = document.getElementById('sideBar');\n  const topNav = document.getElementById('topNav');\n  const bottomNav = document.getElementById('bottomNav');\n  const settingButton = document.getElementById('setting-button');\n  const bottomMenuButton = document.getElementById('bottom-menu-button');\n  const pageModeSingleButton = document.getElementById(\n    'page-mode-single-button',\n  );\n  const pageModeDualButton = document.getElementById('page-mode-dual-button');\n  const pageModeDualFirstButton = document.getElementById(\n    'page-mode-dual-first-button',\n  );\n  const pageModeScrollButton = document.getElementById(\n    'page-mode-scroll-button',\n  );\n  const currentPageSpan = document.getElementById('currentPage');\n  const totalPagesSpan = document.getElementById('totalPages');\n  const sliderRangeInput = document.getElementById('slider-range');\n  const prevButton = document.getElementById('prev-button');\n  const nextButton = document.getElementById('next-button');\n\n  const fileTypeEpubButton = document.getElementById('file-type-epub-button');\n  const fileTypePdfButton = document.getElementById('file-type-pdf-button');\n  const fileTypeComicButton = document.getElementById('file-type-comic-button');\n\n  /** @type {Array<EventBus>} event 저장 array */\n  const eventStore = [];\n\n  /**\n   * 파일타입\n   */\n  let fileType = FileType.EPUB;\n  // let fileType = FileType.COMIC;\n  /**\n   * @type {number} 전체 사이즈\n   */\n  let total = 0;\n  /**\n   * @type {Array<>} 보여질 아이템 list\n   */\n  let items = [];\n  /**\n   *  @type {PageMode} - A variable that accepts only values from the PageMode enum.\n   */\n  const defaultPageMode = PageMode.SINGLE;\n  /**\n   * @type {PageMode} - A variable that accepts only values from the PageMode enum.\n   */\n  let currentPageMode = defaultPageMode;\n  /**\n   * @type {number} 현재 파일 번호\n   */\n  let currentFileNo = -1;\n  /**\n   * 현재 zoom scale\n   */\n  let currentZoomScale = 1.0;\n  /**\n   * @type {Array<>} 목차 list\n   */\n  let tocList = [];\n  /**\n   * @type {Array<>} Annotation list\n   */\n  let AnnotationList = [];\n\n  /**\n   * PDF\n   */\n  const workerSrc =\n    'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.6.347/pdf.worker.min.js';\n\n  let pdfDocument = null;\n\n  if (window.pdfjsLib && pdfjsLib) {\n    pdfjsLib.GlobalWorkerOptions.workerSrc = workerSrc;\n  }\n\n  /**\n   * ZIP\n   */\n\n  let zipObject = null;\n\n  /**\n   * EPUB\n   */\n\n  let epubRootDir = '';\n  /**\n   * 페이지 정보 map\n   */\n  let pageMap = new Map();\n  /**\n   * 전체 페이지 갯수\n   */\n  let totalPageCount = -1;\n  /**\n   * EPUB전용 현재 페이지 번호\n   */\n  let currentEpubPage = -1;\n\n  /**\n   * SAMPLE\n   */\n  // let pdfSample = 'sample/pdf/sample2.pdf';\n\n  // let comicSample = 'sample/comic/124412124.zip';\n\n  // let epubSample = 'sample/epub/25951631.epub';\n  // let epubSample = 'sample/epub/childrens-literature.epub';\n  // let pdfSample =\n  function initError(err) {\n    console.error('[init][error]', err);\n  }\n  /**\n   * 완전 초기화\n   */\n  function reset() {\n    Utils.removeAllChildren(viewerDiv);\n    total = 0;\n    items = [];\n    currentPageMode = defaultPageMode;\n    currentFileNo = -1;\n    currentZoomScale = 1.0;\n    tocList = [];\n    AnnotationList = [];\n    epubRootDir = '';\n    totalPageCount = -1;\n    pageMap = new Map();\n  }\n\n  function updateSlider(total) {\n    // sliderRangeInput.value = 0;\n    sliderRangeInput.max = total - 1;\n    sliderRangeInput.min = 0;\n    sliderRangeInput.step = 0.1;\n  }\n\n  function init(fileUrl, fileTypeParam) {\n    reset();\n    Utils.removeAllChildren(viewerDiv);\n    viewerContainer = Builder.createViewerContainer();\n    viewerContainer.addEventListener('scroll', () => {\n      View.updateCurrentPosition();\n    });\n\n    if (fileTypeParam) {\n      if (fileTypeParam == FileType.EPUB) {\n        fileType = FileType.EPUB;\n      } else if (fileTypeParam == FileType.PDF) {\n        fileType = FileType.PDF;\n      } else if (fileTypeParam == FileType.COMIC || fileTypeParam == 'zip') {\n        fileType = FileType.COMIC;\n      } else {\n        throw Error('Not Support Viewer Type');\n      }\n    }\n    viewerDiv.appendChild(viewerContainer);\n    viewerDiv.dataset.filetype = fileType;\n\n    sliderRangeInput.value = 0;\n    sliderRangeInput.max = total - 1;\n    sliderRangeInput.min = 0;\n    sliderRangeInput.step = 0.1;\n\n    bottomMenuButton.hidden = true;\n    pageModeDualButton.hidden = false;\n    pageModeDualFirstButton.hidden = true;\n    settingButton.hidden = true;\n    if (fileType == FileType.EPUB) {\n    } else if (fileType == FileType.PDF) {\n      pageModeDualButton.hidden = true;\n    } else if (fileType == FileType.COMIC) {\n    }\n\n    if (fileType == FileType.EPUB) {\n      /**\n       * Epub 랜더링\n       */\n      FileHandler.fetchAndExtractZipPaths(fileUrl ? fileUrl : childrens_literature)\n        .then(rs => {\n          zipObject = rs.zip;\n          items = rs.paths;\n          total = items.length;\n          const containerXml = items.find(it =>\n            it.src.endsWith('container.xml'),\n          );\n          const opf = items.find(it => it.src.endsWith('opf'));\n          const ncx = items.find(it => it.src.endsWith('ncx'));\n\n          /**\n           * Epub의 BASE Root Directory를 탐색\n           */\n          XmlToJsonConverter.getRootDir(containerXml.src)\n            .then(rootDir => {\n              epubRootDir = rootDir;\n              /**\n               * Epub OPF를 찾아 페이지를 구성한다.\n               */\n              XmlToJsonConverter.parseOPF(opf.src)\n                .then(parsedOPF => {\n                  /**\n                   * items를 만들어 할당\n                   */\n                  items = parsedOPF;\n                  total = items.length;\n                  /**\n                   * 목차 파싱\n                   */\n                  XmlToJsonConverter.parseToc(ncx.src)\n                    .then(parsedToc => {\n                      if (Array.isArray(parsedToc)) {\n                        tocList = parsedToc;\n                      }\n                      /**\n                       * Epub 랜더링\n                       */\n                      currentPageMode = PageMode.DUAL;\n                      View.setPageMode(currentPageMode);\n                      View.updateCurrentPosition();\n                    })\n                    .catch(err => {\n                      initError(err);\n                    });\n                })\n                .catch(err => {\n                  initError(err);\n                });\n            })\n            .catch(err => {\n              initError(err);\n            });\n        })\n        .catch(err => {\n          initError(err);\n        });\n    } else if (fileType == FileType.PDF) {\n      /**\n       * PDF 랜더링\n       */\n      const loadingTask = pdfjsLib.getDocument(fileUrl ? fileUrl : sample2);\n      currentFileNo = 1;\n      loadingTask.promise\n        .then(doc => {\n          pdfDocument = doc;\n          total = pdfDocument.numPages;\n\n          updateSlider(total);\n\n          View.setPageMode(currentPageMode);\n          View.updateCurrentPosition();\n        })\n        .catch(err => {\n          initError(err);\n        });\n    } else if (fileType == FileType.COMIC) {\n      /**\n       * comic 랜더링\n       */\n      FileHandler.fetchAndExtractZipPaths(fileUrl ? fileUrl : _124412124)\n        .then(rs => {\n          zipObject = rs.zip;\n          /**\n           * 디렉토리 false\n           * 이미지 true\n           * 썸네일 false\n           * 에 해당되는 애들만 items에 담아서 랜더링 해준다.\n           */\n          items = rs.paths.filter(\n            it => !it.isDirectory && it.isImage && !it.isThumbnail,\n          );\n          total = items.length;\n\n          updateSlider(total);\n          console.log('##currentPageMode', currentPageMode);\n          View.setPageMode(currentPageMode);\n          View.updateCurrentPosition();\n        })\n        .catch(err => {\n          initError(err);\n        });\n    }\n  }\n\n  /**\n   * @class\n   * 통신이나,랜더링 워커\n   *\n   */\n  const Walker = {\n    /**\n     * fetch Resource\n     * @param {number} fileno\n     */\n    getResource(fileno, callback) {\n      return new Promise((resolve, reject) => {\n        if (items[fileno]) {\n          this.fetchImageBuffer(items[fileno].src)\n            .then(arrayBuffer => {\n              resolve(arrayBuffer);\n            })\n            .catch(err => {\n              reject(err);\n            });\n        } else {\n          reject(new Error('no file '));\n        }\n      });\n    },\n    fetchImageBuffer: async url => {\n      try {\n        const response = await fetch(url);\n        if (!response.ok) {\n          throw new Error(`HTTP error! Status: ${response.status}`);\n        }\n        const arrayBuffer = await response.arrayBuffer();\n        return arrayBuffer;\n      } catch (error) {\n        console.error('Failed to fetch image buffer:', error);\n      }\n    },\n    /**\n     * PDF canvas랜더링\n     * @param {number} index\n     * @param {Function} loadCallback\n     * @returns\n     */\n    createCanvasWithIndexPDF: (index, loadCallback) => {\n      const canvas = document.createElement('canvas');\n      canvas.style.position = 'absolute';\n      canvas.dataset.page = index;\n\n      // 최적 스케일 계산 (부모 컨테이너에 맞춤)\n      const calculateOptimalScale = (\n        parentRect,\n        originalWidth,\n        originalHeight,\n      ) => {\n        const parentWidth = parentRect.width;\n        const parentHeight = parentRect.height;\n        const scaleWidth = parentWidth / originalWidth;\n        const scaleHeight = parentHeight / originalHeight;\n        return Math.min(scaleWidth, scaleHeight); // 화면에 맞는 최소 스케일 선택\n      };\n      pdfDocument\n        .getPage(index + 1)\n        .then(pdfPage => {\n          const ctx = canvas.getContext('2d');\n          const devicePixelRatio = window.devicePixelRatio || 1;\n          const backingStoreRatio =\n            ctx.webkitBackingStorePixelRatio ||\n            ctx.mozBackingStorePixelRatio ||\n            ctx.msBackingStorePixelRatio ||\n            ctx.oBackingStorePixelRatio ||\n            ctx.backingStorePixelRatio ||\n            1;\n          const ratio = devicePixelRatio / backingStoreRatio;\n\n          const scaleValue = 1 * devicePixelRatio;\n          const viewport = pdfPage.getViewport({ scale: scaleValue });\n          const parentRect = viewerContainer.getBoundingClientRect();\n          const originalWidth = viewport.width; // PDF 페이지의 원본 너비\n          const originalHeight = viewport.height; // PDF 페이지의 원본 높이\n\n          const optimalScale = calculateOptimalScale(\n            parentRect,\n            originalWidth,\n            originalHeight,\n          );\n\n          // 최종 Viewport 재계산 (고해상도 디스플레이 포함)\n          const finalScale = optimalScale * devicePixelRatio; // 디바이스 픽셀 비율 반영\n          const viewportRescale = pdfPage.getViewport({ scale: finalScale });\n          const renderContext = {\n            canvasContext: ctx,\n            viewport: viewportRescale,\n            enableWebGL: true,\n          };\n\n          // 스무딩 설정\n          ctx.imageSmoothingEnabled = true; // 이미지 스무딩 활성화\n          ctx.imageSmoothingQuality = 'high'; // 고품질 스무딩 설정\n\n          canvas.width = Math.floor(viewportRescale.width);\n          canvas.height = Math.floor(viewportRescale.height);\n\n          pdfPage\n            .render(renderContext)\n            .promise.then(() => {\n              if (loadCallback) {\n                loadCallback(canvas);\n              }\n            })\n            .catch(err => {\n              if (loadCallback) {\n                loadCallback(null, err);\n              }\n            });\n        })\n        .catch(err => {\n          if (loadCallback) {\n            loadCallback(null, err);\n          }\n        });\n\n      return canvas;\n    },\n    /**\n     * index번호로 canvas 생성\n     * @param {number} index\n     * @param {number} zoomScale\n     * @param {Function} loadCallback\n     * @returns\n     */\n    createCanvasWithIndex: (index, loadCallback) => {\n      const canvas = document.createElement('canvas');\n      canvas.style.position = 'absolute';\n      canvas.dataset.page = index;\n\n      const imageUrl = items[index].src;\n      const img = new Image();\n      FileHandler.getFileUrlFromZip(zipObject, imageUrl)\n        .then(url => {\n          img.src = url;\n        })\n        .catch(err => {\n          if (loadCallback) {\n            loadCallback(null, e);\n          }\n        });\n\n      img.onload = () => {\n        const ctx = canvas.getContext('2d', { alpha: false });\n        const devicePixelRatio = window.devicePixelRatio || 1;\n        const backingStoreRatio =\n          ctx.webkitBackingStorePixelRatio ||\n          ctx.mozBackingStorePixelRatio ||\n          ctx.msBackingStorePixelRatio ||\n          ctx.oBackingStorePixelRatio ||\n          ctx.backingStorePixelRatio ||\n          1;\n        const ratio = devicePixelRatio / backingStoreRatio;\n        /**\n         * 원본 이미지 사이즈\n         */\n        const originalWidth = img.width;\n        const originalHeight = img.height;\n\n        /**\n         * parent의 사이즈\n         */\n        const parentRect = viewerContainer.getBoundingClientRect();\n        const parentWidth = parentRect.width;\n        const parentHeight = parentRect.height;\n\n        // 원본의 비율\n        const aspectRatio = originalWidth / originalHeight;\n\n        /**\n         * 목표하는 width, height값을 원본에 비율에 맞춰 재조정하는 작업\n         */\n        let newCanvasWidth = parentWidth;\n        let newCanvasHeight = parentWidth / aspectRatio;\n\n        // Check if the new height exceeds the parent height, and if so, adjust the width accordingly\n        if (newCanvasHeight > parentHeight) {\n          newCanvasHeight = parentHeight;\n          newCanvasWidth = parentHeight * aspectRatio;\n        }\n\n        // Calculate the scaling factor for width and height\n        const widthScale = newCanvasWidth / originalWidth;\n        const heightScale = newCanvasHeight / originalHeight;\n\n        // Apply the scaling factor to original dimensions\n        const scaledCanvasWidth = originalWidth * widthScale;\n        const scaledCanvasHeight = originalHeight * heightScale;\n\n        // console.log(\n        //   canvas.dataset.page,\n        //   originalWidth,\n        //   originalHeight,\n        //   widthScale,\n        //   heightScale,\n        // );\n\n        canvas.width = Math.floor(scaledCanvasWidth * ratio * currentZoomScale);\n        canvas.height = Math.floor(\n          scaledCanvasHeight * ratio * currentZoomScale,\n        );\n\n        ctx.imageSmoothingEnabled = true;\n        ctx.imageSmoothingQuality = 'high';\n        ctx.scale(ratio * currentZoomScale, ratio * currentZoomScale);\n        ctx.drawImage(img, 0, 0, scaledCanvasWidth, scaledCanvasHeight);\n        if (loadCallback) {\n          loadCallback(canvas);\n        }\n      };\n\n      img.onerror = e => {\n        if (loadCallback) {\n          loadCallback(null, e);\n        }\n      };\n\n      return canvas;\n    },\n    /**\n     * 양면일경우에 index번호로 canvas 생성\n     * @param {number} index\n     * @param {number} zoomScale\n     * @param {Function} loadCallback\n     * @returns\n     */\n    createCanvasWithIndex2: (index, loadCallback) => {\n      const canvas = document.createElement('canvas');\n      canvas.style.position = 'absolute';\n      const canvasColor = 'rgba(255, 255, 255, 1)';\n      canvas.dataset.page = index;\n\n      const imageUrl1 = items[index]?.src; // 왼쪽 이미지\n      const imageUrl2 = items[index + 1]?.src; // 오른쪽 이미지 (짝수 페이지일 경우)\n\n      const img1 = new Image();\n      const img2 = new Image();\n\n      let imagesLoaded = 0;\n\n      const safeDivide = (numerator, denominator) => {\n        return denominator === 0 ? 0 : numerator / denominator;\n      };\n\n      const onImagesLoaded = () => {\n        const ctx = canvas.getContext('2d', { alpha: false });\n        const devicePixelRatio = window.devicePixelRatio || 1;\n        const backingStoreRatio =\n          ctx.webkitBackingStorePixelRatio ||\n          ctx.mozBackingStorePixelRatio ||\n          ctx.msBackingStorePixelRatio ||\n          ctx.oBackingStorePixelRatio ||\n          ctx.backingStorePixelRatio ||\n          1;\n        const ratio = devicePixelRatio / backingStoreRatio;\n\n        // 원본 이미지 크기\n        const originalWidth1 = img1.width || 0;\n        const originalHeight1 = img1.height || 0;\n        const originalWidth2 = img2.width || 0;\n        const originalHeight2 = img2.height || 0;\n\n        // 각 이미지 비율 계산 (with safeDivide)\n        const aspectRatio1 = safeDivide(originalWidth1, originalHeight1);\n        const aspectRatio2 = safeDivide(originalWidth2, originalHeight2);\n\n        // parent의 크기 가져오기\n        const parentRect = viewerContainer.getBoundingClientRect();\n        const parentWidth = parentRect.width;\n        const parentHeight = parentRect.height;\n\n        // 새로운 캔버스 크기 계산\n        let newWidth1 = parentWidth / 2; // 왼쪽 이미지 절반 크기\n        let newHeight1 = safeDivide(newWidth1, aspectRatio1);\n        let newWidth2 = parentWidth / 2; // 오른쪽 이미지 절반 크기\n        let newHeight2 = safeDivide(newWidth2, aspectRatio2);\n\n        // 높이가 parent를 초과하면 너비를 조정\n        if (newHeight1 > parentHeight) {\n          newHeight1 = parentHeight;\n          newWidth1 = newHeight1 * aspectRatio1;\n        }\n        if (newHeight2 > parentHeight) {\n          newHeight2 = parentHeight;\n          newWidth2 = newHeight2 * aspectRatio2;\n        }\n\n        // 캔버스 전체 크기 설정\n        const scaledCanvasWidth =\n          (newWidth1 + newWidth2) * currentZoomScale * ratio;\n        const scaledCanvasHeight =\n          Math.max(newHeight1, newHeight2) * currentZoomScale * ratio;\n\n        canvas.width = Math.floor(scaledCanvasWidth);\n        canvas.height = Math.floor(scaledCanvasHeight);\n        ctx.scale(ratio * currentZoomScale, ratio * currentZoomScale);\n\n        // 캔버스 배경 설정\n        ctx.fillStyle = canvasColor;\n        ctx.fillRect(\n          0,\n          0,\n          canvas.width / (ratio * currentZoomScale),\n          canvas.height / (ratio * currentZoomScale),\n        );\n\n        // 첫 번째 이미지 (왼쪽)\n        ctx.drawImage(img1, 0, 0, newWidth1, newHeight1);\n\n        // 두 번째 이미지 (오른쪽) 또는 빈 배경\n        if (img2.src) {\n          const verticalOffset = Math.max(0, (newHeight1 - newHeight2) / 2);\n          ctx.drawImage(img2, newWidth1, verticalOffset, newWidth2, newHeight2);\n        } else {\n          ctx.fillStyle = canvasColor; // 빈 배경\n          ctx.fillRect(newWidth1, 0, newWidth1, newHeight1);\n        }\n\n        // 콜백 호출\n        if (loadCallback) {\n          loadCallback(canvas);\n        }\n      };\n\n      const handleImageLoad = () => {\n        imagesLoaded++;\n        if (imagesLoaded === 2 || (imagesLoaded === 1 && !imageUrl2)) {\n          onImagesLoaded();\n        }\n      };\n\n      // 첫 번째 이미지 로드\n      img1.onload = handleImageLoad;\n      img1.onerror = e => {\n        if (loadCallback) loadCallback(null, e);\n      };\n      FileHandler.getFileUrlFromZip(zipObject, imageUrl1)\n        .then(url => {\n          img1.src = url;\n        })\n        .catch(err => {\n          console.log(err);\n          if (loadCallback) {\n            loadCallback(null, e);\n          }\n        });\n      // 두 번째 이미지 로드 (있는 경우)\n      if (imageUrl2) {\n        img2.onload = handleImageLoad;\n        img2.onerror = e => {\n          if (loadCallback) loadCallback(null, e);\n        };\n        FileHandler.getFileUrlFromZip(zipObject, imageUrl2)\n          .then(url => {\n            img2.src = url;\n          })\n          .catch(err => {\n            console.log(err);\n            if (loadCallback) {\n              loadCallback(null, e);\n            }\n          });\n      } else {\n        imagesLoaded++; // 두 번째 이미지가 없으면 바로 증가\n      }\n\n      return canvas;\n    },\n    /**\n     * index로 HTML을 찾는 로직\n     * @param {number} index\n     * @param {Function} loadCallback\n     */\n    createHtmlWithIndex: (index, loadCallback) => {\n      const item = items[index];\n      const doc = document.createDocumentFragment();\n      FileHandler.getFileFromZip(zipObject, item.href, 'string')\n        .then(htmlString => {\n          const promises = [];\n          const promiseImgs = [];\n          const fragment = document\n            .createRange()\n            .createContextualFragment(htmlString);\n\n          /**\n           * BOBY를 찾아준다.\n           */\n          const firstNonExcludedElementList = Array.from(\n            fragment.children,\n          ).filter(it => {\n            if (\n              it.nodeName === 'TITLE' ||\n              it.nodeName === 'SCRIPT' ||\n              it.nodeName === 'LINK'\n            ) {\n              return false;\n            }\n            return true; // Return true to find the first element that is not excluded\n          });\n          /**\n           * Atag, 링크 url를 찾아서 넣어준다.\n           */\n          fragment.querySelectorAll('link').forEach(link => {\n            const linkUrl = Utils.replaceEpubPathUrl(link.href);\n            promises.push(\n              FileHandler.getFileFromZip(zipObject, linkUrl, 'string'),\n            );\n          });\n          /**\n           * IMG, 찾아준다.\n           */\n          fragment.querySelectorAll('[src]').forEach(img => {\n            const linkUrl = Utils.replaceEpubPathUrl(img.src);\n            promiseImgs.push(\n              FileHandler.getFileFromZip(\n                zipObject,\n                linkUrl,\n                'blob',\n                true,\n                index,\n              ),\n            );\n          });\n\n          /**\n           * 스타일 속성, 한번에 진행\n           */\n          Promise.all(promises)\n            .then(styles => {\n              const styleTag = document.createElement('style');\n              styleTag.type = 'text/css';\n              styles.forEach(styleContent => {\n                styleTag.appendChild(document.createTextNode(styleContent));\n              });\n              /**\n               * 뷰잉을 위한 추가 스타일링은 이쪽에서 추가하면 된다.\n               */\n              styleTag.appendChild(\n                document.createTextNode(`\n                p[data-empty] {\n                  margin: 0 !important;\n                  padding: 0 !important;\n                  position: relative !important;\n                  visibility: visible !important;\n                  text-indent: 0 !important;\n                  line-height: 0 !important;\n                  font-size: medium !important;\n                }\n                p[data-empty=\"false\"] {\n                  display: none;\n                }\n                /* 애니메이션 정의 */\n                @keyframes bounce {\n                  0%, 100% {\n                    transform: translateY(0);\n                  }\n                  50% {\n                    transform: translateY(-30px);\n                  }\n                }\n\n                /* 바운스 애니메이션 적용 */\n                .bounce-once {\n                  animation: bounce 0.5s ease-in-out;\n                  animation-fill-mode: forwards; /* 애니메이션 후 상태 유지 */\n                }\n                  \n                a {\n                  text-decoration: none; /* Remove underline */\n                  color: blue; /* Inherit the color from the parent element */\n                  transition: color 0.3s ease, text-decoration 0.3s ease; /* Smooth transition for color and text decoration */\n                }\n\n                a:hover, a:focus, a:active {\n                  color: #3498db; /* Smooth blue color */\n                  text-decoration: none; /* Ensure no underline on hover, focus, or active */\n                }\n                `),\n              );\n              /**\n               * 이미지 blob한번에 진행\n               */\n              Promise.all(promiseImgs)\n                .then(images => {\n                  // Initialize counters\n                  let imagesLoadedCount = 0;\n                  let totalImagesCount = 0;\n                  const onLoadFnc = e => {\n                    // console.log('## Image loaded:', e.target);\n                    imagesLoadedCount++; // Increment count when an image is loaded\n\n                    // Check if all images have been loaded\n                    if (imagesLoadedCount === totalImagesCount) {\n                      const spaceTag = document.createElement('p');\n                      spaceTag.dataset.empty = true;\n\n                      if (loadCallback) {\n                        loadCallback(\n                          { doc: doc, link: styleTag, spaceTag: spaceTag },\n                          null,\n                        );\n                      }\n                    }\n                  };\n\n                  let hasImg = false;\n                  firstNonExcludedElementList.forEach(\n                    firstNonExcludedElement => {\n                      const node = firstNonExcludedElement.cloneNode(true);\n                      const list = node.querySelectorAll('[src]');\n                      /**\n                       * 찾은 객체 자체가 img일경우\n                       */\n                      if (node.src) {\n                        totalImagesCount++; // Increment total image count\n                        const linkUrl = Utils.replaceEpubPathUrl(node.src);\n                        const find = images.find(it => it.src == linkUrl);\n                        const imgUrl = URL.createObjectURL(find.blob);\n                        node.src = imgUrl;\n                        node.onload = onLoadFnc;\n                        hasImg = true;\n                      }\n\n                      /**\n                       * 안쪽컨텐츠들이 img일 경우\n                       */\n                      list.forEach(srcElement => {\n                        totalImagesCount++; // Increment total image count\n                        const linkUrl = Utils.replaceEpubPathUrl(\n                          srcElement.src,\n                        );\n                        const find = images.find(it => it.src == linkUrl);\n                        const imgUrl = URL.createObjectURL(find.blob);\n                        srcElement.src = imgUrl;\n                        srcElement.onload = onLoadFnc;\n                        hasImg = true;\n                      });\n\n                      doc.appendChild(node);\n                    },\n                  );\n\n                  if (!hasImg) {\n                    const spaceTag = document.createElement('p');\n                    spaceTag.dataset.empty = true;\n\n                    if (loadCallback) {\n                      loadCallback(\n                        { doc: doc, link: styleTag, spaceTag: spaceTag },\n                        null,\n                      );\n                    }\n                  }\n                })\n                .catch(err => {\n                  if (loadCallback) {\n                    loadCallback(null, err);\n                  }\n                });\n            })\n            .catch(err => {\n              if (loadCallback) {\n                loadCallback(null, err);\n              }\n            });\n        })\n        .catch(err => {\n          console.error(err);\n          if (loadCallback) {\n            loadCallback(null, err);\n          }\n        });\n      return doc;\n    },\n  };\n\n  /**\n   * @class\n   * Element Builder Class\n   *\n   */\n  const Builder = {\n    /**\n     * 파일번호 기준으로 랜더링 div생성\n     * @param {number} fileno 파일번호\n     * @returns\n     */\n    createRenderingDiv(fileno) {\n      function getRandomRgbColor() {\n        const r = Math.floor(Math.random() * 256); // Red (0-255)\n        const g = Math.floor(Math.random() * 256); // Green (0-255)\n        const b = Math.floor(Math.random() * 256); // Blue (0-255)\n        return `rgb(${r}, ${g}, ${b})`;\n      }\n      const divRendering = document.createElement('div');\n      divRendering.id = 'rendering-div-' + fileno;\n      divRendering.style.position = 'relative';\n      divRendering.dataset.page = fileno;\n      if (items[fileno]?.hrefOrigin) {\n        divRendering.dataset.src = items[fileno]?.hrefOrigin;\n      }\n      if (IS_DEBUG) {\n        divRendering.style.backgroundColor = getRandomRgbColor();\n      }\n\n      divRendering.style.width = '100%';\n      divRendering.style.height = '100%';\n      divRendering.style.display = 'inline-block';\n      return divRendering;\n    },\n    /**\n     * scroll container만들기\n     * @returns\n     */\n    createViewerContainer() {\n      const div = document.createElement('div');\n      div.id = 'viewer-container';\n      div.style.width = '100%';\n      div.style.height = '100%';\n      div.style.overflowX = 'auto';\n      if (fileType != FileType.EPUB) {\n        div.style.whiteSpace = 'nowrap';\n      }\n\n      div.style.position = 'relative';\n      div.style.margin = 0;\n      div.style.padding = 0;\n      div.style.lineHeight = 0;\n      return div;\n    },\n  };\n\n  /**\n   * @class\n   * View Class\n   *\n   */\n  const View = (INSTANCE.View = {\n    /**\n     * Navbar Toggle\n     */\n    toggleNav() {\n      topNav.classList.toggle('hidden');\n      bottomNav.classList.toggle('hidden');\n    },\n    /**\n     * 전체 캔버스 사이즈 조정한다.\n     */\n    resizeAll() {\n      if (fileType != FileType.EPUB) {\n        document.querySelectorAll('canvas').forEach(_canvas => {\n          this.resizeCanvas(_canvas);\n        });\n      }\n    },\n    /**\n     * Epub ,리사이징 함수\n     * @param {HTMLElement} _element\n     */\n    resizeElement(_element) {\n      const parentRect = viewerDiv.getBoundingClientRect();\n\n      _element.style.overflowX = null;\n      _element.style.overflowY = null;\n      if (currentPageMode == PageMode.SINGLE) {\n        /**\n         * 단면 모드\n         */\n        _element.style.display = 'block';\n        _element.style.width = null;\n        _element.style.maxWidth = null;\n        _element.style.minWidth = null;\n\n        _element.style.height = 'auto';\n        _element.style.maxHeight = null;\n        _element.style.minHeight = parentRect.height + 'px';\n      } else if (\n        currentPageMode == PageMode.DUAL ||\n        currentPageMode == PageMode.FIRST_DUAL\n      ) {\n        /**\n         * 양면 모드\n         */\n        _element.style.display = 'block';\n        _element.style.width = null;\n        _element.style.maxWidth = null;\n        _element.style.minWidth = null;\n\n        _element.style.height = 'auto';\n        _element.style.maxHeight = null;\n        _element.style.minHeight = parentRect.height + 'px';\n      } else if (currentPageMode == PageMode.SCROLL) {\n        /**\n         * 스크롤 모드\n         */\n        _element.style.display = 'block';\n        _element.style.overflow = 'auto';\n\n        _element.style.width = parentRect.width + 'px';\n        _element.style.maxWidth = parentRect.width + 'px';\n        _element.style.minWidth = null;\n\n        _element.style.height = null;\n        _element.style.maxHeight = null;\n        _element.style.minHeight = parentRect.height + 'px';\n      }\n    },\n    applyStylesAndObserve(viewerContainer, currentPageMode) {\n      return new Promise((resolve, reject) => {\n        let mutationCount = 0; // To count the number of mutations\n        let totalMutations = 0; // Total mutations to wait for\n        const observedElements = new Set(); // To keep track of elements we're observing\n\n        // MutationObserver callback\n        const observer = new MutationObserver(mutations => {\n          mutations.forEach(mutation => {\n            if (\n              mutation.type === 'attributes' &&\n              mutation.attributeName === 'style'\n            ) {\n              mutationCount++;\n              // If all mutations are done, resolve the promise\n              if (mutationCount === totalMutations) {\n                resolve('All style changes applied');\n                observer.disconnect();\n              }\n            }\n          });\n        });\n\n        Array.from(viewerContainer.children).forEach(child => {\n          let srcTags = child.shadowRoot.querySelectorAll('[src]');\n          srcTags.forEach(srcTag => {\n            // Only observe if not already observed\n            if (!observedElements.has(srcTag)) {\n              observedElements.add(srcTag);\n\n              observer.observe(srcTag, {\n                attributes: true, // Observe style changes\n              });\n              totalMutations++; // Increase total mutations to wait for\n\n              const parentRect = viewerContainer.getBoundingClientRect();\n\n              if (currentPageMode === PageMode.SCROLL) {\n                srcTag.style.maxWidth = parentRect.width + 'px';\n              } else {\n                srcTag.style.maxWidth = viewerContainer.style.columnWidth;\n              }\n\n              // Adjust maxHeight considering lineHeight\n              const computedStyle = window.getComputedStyle(srcTag);\n              if (computedStyle.lineHeight) {\n                srcTag.style.maxHeight =\n                  parentRect.height - parseInt(computedStyle.lineHeight) + 'px';\n              } else {\n                srcTag.style.maxHeight = parentRect.height + 'px';\n              }\n            }\n          });\n        });\n\n        // In case no styles change (fallback)\n        setTimeout(() => {\n          if (mutationCount === 0) {\n            resolve('No styles applied');\n          }\n        }, 1000); // Timeout to avoid waiting indefinitely\n      });\n    },\n    /**\n     * EPUB\n     * 페이지나눔이 제대로 되었나 체크\n     * 안되어있으면 empty tag에 사이즈를 조정해준다.\n     */\n    checkPageDivide() {\n      let pos = 0;\n      let totalLoop = 0;\n      Array.from(viewerContainer.children).forEach(child => {\n        /**\n         * 빈공간만큼 data-empty tag로 보정해준다.\n         */\n        const parentRect = viewerDiv.getBoundingClientRect();\n        let emptyTag = child.shadowRoot.querySelector('[data-empty]');\n        if (emptyTag) {\n          emptyTag.style.height = null;\n\n          emptyTag = child.shadowRoot.querySelector('[data-empty]');\n          let emptyTagRect = emptyTag.getBoundingClientRect();\n          let bottomChild = emptyTagRect.top + emptyTagRect.height;\n          let bottomDiff = parentRect.top + parentRect.height - bottomChild;\n\n          if (\n            currentPageMode == PageMode.DUAL ||\n            currentPageMode == PageMode.FIRST_DUAL\n          ) {\n            const childRects = child.getClientRects();\n            const childRectsLen = childRects.length;\n            if (childRectsLen % 2 != 0) {\n              emptyTag.style.height = bottomDiff + parentRect.height + 'px';\n              // emptyTag.style.height = bottomDiff + 'px';\n            } else {\n              if (bottomDiff >= 0) {\n                emptyTag.style.height = bottomDiff + 'px';\n              }\n            }\n          } else if (currentPageMode == PageMode.SINGLE) {\n            emptyTag.style.height = bottomDiff + 'px';\n          } else {\n            emptyTag.style.height = null;\n          }\n        }\n        /**\n         * 여기서부턴 페이지 계산.\n         */\n\n        //파일번호\n        const fileNumber = Number(child.dataset.page);\n        // page정보 List\n        const pageList = [];\n        /**\n         * 스크롤 모드일때 계산.\n         */\n        if (currentPageMode == PageMode.SCROLL) {\n          const viewerParentRect = viewerDiv.getBoundingClientRect();\n          const viewerParentHeight = viewerParentRect.height;\n          const childHeight = child.offsetHeight;\n          const expectTotalPage = Math.ceil(childHeight / viewerParentHeight);\n          for (let index = 0; index < expectTotalPage; index++) {\n            pageList.push({\n              position: pos,\n              file: fileNumber,\n              pageNumber: totalLoop,\n            });\n            pos += viewerParentHeight;\n            totalLoop++;\n          }\n          pageMap.set(fileNumber, { page: expectTotalPage, pageList });\n        } else {\n          const columnWidth = parseFloat(viewerContainer.style.columnWidth);\n          const columnGap = parseFloat(viewerContainer.style.columnGap) / 2;\n          const rects = child.getClientRects();\n          const page = rects.length;\n          for (let index = 0; index < rects.length; index++) {\n            pageList.push({\n              position: pos,\n              file: fileNumber,\n              pageNumber: totalLoop,\n            });\n            if (currentPageMode == PageMode.SINGLE) {\n              pos += columnWidth + columnGap * 4;\n            } else {\n              pos += columnWidth + columnGap + columnGap * 2;\n            }\n\n            totalLoop++;\n          }\n          pageMap.set(fileNumber, { page, pageList });\n        }\n      });\n      totalPageCount = totalLoop;\n\n      // console.log(pageMap);\n      // tocList.forEach(toc => {\n      //   // const range = Position.findPositionInHref(pageMap, toc.src);\n      //   // console.log(range, toc);\n      // });\n    },\n    /**\n     * canvas사이즈를 조정한다.\n     * @param {HTMLCanvasElement} _canvas\n     */\n    resizeCanvas(_canvas) {\n      const parentRect = viewerContainer.getBoundingClientRect();\n      const scaleX = parentRect.width / _canvas.width;\n      const scaleY = parentRect.height / _canvas.height;\n\n      // 이미지의 크기를 부모의 크기에 맞게 스케일 다운\n      const scale = Math.min(scaleX, scaleY);\n\n      // 스케일된 이미지의 최종 크기\n      const scaledWidth = _canvas.width * scale;\n      const scaledHeight = _canvas.height * scale;\n\n      _canvas.style.width = scaledWidth + 'px';\n      _canvas.style.height = scaledHeight + 'px';\n\n      if (currentPageMode == PageMode.SINGLE) {\n        _canvas.parentElement.style.display = 'inline-block';\n        _canvas.parentElement.style.width =\n          parentRect.width * currentZoomScale + 'px';\n        _canvas.parentElement.style.height =\n          parentRect.height * currentZoomScale + 'px';\n\n        // Get the dimensions of the parent and child\n        const parentWidth = _canvas.parentElement.offsetWidth;\n        const parentHeight = _canvas.parentElement.offsetHeight;\n        const childWidth = _canvas.offsetWidth;\n        const childHeight = _canvas.offsetHeight;\n\n        // Calculate the center position\n        const centerX = (parentWidth - childWidth) / 2;\n        const centerY = (parentHeight - childHeight) / 2;\n\n        _canvas.style.top = centerY + 'px';\n        _canvas.style.left = centerX + 'px';\n        _canvas.style.transform = null;\n      } else if (currentPageMode == PageMode.DUAL) {\n        _canvas.parentElement.style.display = 'inline-block';\n        _canvas.parentElement.style.width = parentRect.width + 'px';\n        _canvas.parentElement.style.height = parentRect.height + 'px';\n\n        // Get the dimensions of the parent and child\n        const parentWidth = _canvas.parentElement.offsetWidth;\n        const parentHeight = _canvas.parentElement.offsetHeight;\n        const childWidth = _canvas.offsetWidth;\n        const childHeight = _canvas.offsetHeight;\n\n        // Calculate the center position\n        const centerX = (parentWidth - childWidth) / 2;\n        const centerY = (parentHeight - childHeight) / 2;\n\n        _canvas.style.top = centerY + 'px';\n        _canvas.style.left = centerX + 'px';\n        _canvas.style.transform = null;\n      } else if (currentPageMode == PageMode.FIRST_DUAL) {\n        _canvas.parentElement.style.display = 'inline-block';\n        _canvas.parentElement.style.width = parentRect.width + 'px';\n        _canvas.parentElement.style.height = parentRect.height + 'px';\n\n        // Get the dimensions of the parent and child\n        const parentWidth = _canvas.parentElement.offsetWidth;\n        const parentHeight = _canvas.parentElement.offsetHeight;\n        const childWidth = _canvas.offsetWidth;\n        const childHeight = _canvas.offsetHeight;\n\n        // Calculate the center position\n        const centerX = (parentWidth - childWidth) / 2;\n        const centerY = (parentHeight - childHeight) / 2;\n\n        _canvas.style.top = centerY + 'px';\n        _canvas.style.left = centerX + 'px';\n        _canvas.style.transform = null;\n      } else if (currentPageMode == PageMode.SCROLL) {\n        _canvas.parentElement.style.display = 'block';\n        _canvas.parentElement.style.width = parentRect.width + 'px';\n        _canvas.parentElement.style.height = scaledHeight + 'px';\n\n        // Get the dimensions of the parent and child\n        const parentWidth = _canvas.parentElement.offsetWidth;\n        const parentHeight = _canvas.parentElement.offsetHeight;\n        const childWidth = _canvas.offsetWidth;\n        const childHeight = _canvas.offsetHeight;\n\n        // Calculate the center position\n        const centerX = (parentWidth - childWidth) / 2;\n        const centerY = (parentHeight - childHeight) / 2;\n\n        _canvas.style.top = centerY + 'px';\n        _canvas.style.left = centerX + 'px';\n        _canvas.style.transform = null;\n      }\n    },\n    /**\n     * 페이지 모드를 변경한다.\n     * @param {PageMode} pageMode\n     * @param {boolean} isResize\n     */\n    setPageMode(pageMode, isResize) {\n      if (pageMode != currentPageMode) {\n        currentPageMode = pageMode;\n      }\n      // Draw based on pageMode\n      switch (pageMode) {\n        case PageMode.SINGLE:\n          this.drawSingleMode(isResize);\n          break;\n        case PageMode.DUAL:\n          this.drawDualMode(isResize);\n          break;\n        case PageMode.FIRST_DUAL:\n          this.drawFirstDualMode(isResize);\n          break;\n        case PageMode.SCROLL:\n          this.drawScrollMode(isResize);\n          break;\n        default:\n          console.warn('Unsupported mode:', pageMode);\n      }\n    },\n\n    /**\n     * 한페이지 모드\n     */\n    drawSingleMode(isResize) {\n      viewerContainer.style.overflowX = 'hidden';\n      viewerContainer.style.overflowY = 'hidden';\n      viewerContainer.style.lineHeight = null;\n      if (fileType == FileType.EPUB) {\n        const divdeRatio =\n          currentPageMode == PageMode.DUAL ||\n          currentPageMode == PageMode.FIRST_DUAL\n            ? 2\n            : 1;\n        const parentRect = viewerContainer.getBoundingClientRect();\n        const columnGap = 30;\n        const columnWidth = parentRect.width / divdeRatio - columnGap;\n        viewerContainer.style.columnGap = columnGap + 'px';\n        viewerContainer.style.columnWidth = columnWidth + 'px';\n      } else {\n        viewerContainer.style.columnWidth = null;\n        viewerContainer.style.lineHeight = 0;\n      }\n      this.draw(isResize);\n    },\n    /**\n     * 양면페이지 모드\n     */\n    drawDualMode(isResize) {\n      viewerContainer.style.overflowX = 'hidden';\n      viewerContainer.style.overflowY = 'hidden';\n      viewerContainer.style.lineHeight = null;\n      viewerContainer.style.columnWidth = null;\n\n      if (fileType == FileType.EPUB) {\n        const divdeRatio =\n          currentPageMode == PageMode.DUAL ||\n          currentPageMode == PageMode.FIRST_DUAL\n            ? 2\n            : 1;\n        const parentRect = viewerContainer.getBoundingClientRect();\n        const columnGap = 30;\n        const columnWidth = parentRect.width / divdeRatio - columnGap;\n        viewerContainer.style.columnGap = columnGap + 'px';\n        viewerContainer.style.columnWidth = columnWidth + 'px';\n      } else {\n        viewerContainer.style.columnWidth = null;\n        viewerContainer.style.lineHeight = 0;\n      }\n      this.draw(isResize);\n    },\n    /**\n     * 첫페이지부터 양면 모드\n     */\n    drawFirstDualMode(isResize) {\n      viewerContainer.style.overflowX = 'hidden';\n      viewerContainer.style.overflowY = 'hidden';\n      viewerContainer.style.lineHeight = null;\n      if (fileType == FileType.EPUB) {\n        const divdeRatio =\n          currentPageMode == PageMode.DUAL ||\n          currentPageMode == PageMode.FIRST_DUAL\n            ? 2\n            : 1;\n        const parentRect = viewerContainer.getBoundingClientRect();\n        const columnGap = 30;\n        const columnWidth = parentRect.width / divdeRatio - columnGap;\n        viewerContainer.style.columnGap = columnGap + 'px';\n        viewerContainer.style.columnWidth = columnWidth + 'px';\n      } else {\n        viewerContainer.style.columnWidth = null;\n        viewerContainer.style.lineHeight = 0;\n      }\n      this.draw(isResize);\n    },\n\n    /**\n     * 스크롤 모드\n     */\n    drawScrollMode(isResize) {\n      viewerContainer.style.overflowX = null;\n      viewerContainer.style.overflowY = 'auto';\n      if (fileType == FileType.EPUB) {\n        viewerContainer.style.lineHeight = null;\n      } else {\n        viewerContainer.style.lineHeight = 0;\n      }\n\n      viewerContainer.style.columnWidth = null;\n      viewerContainer.style.columnGap = null;\n      this.draw(isResize);\n    },\n    /**\n     * 다시 그려준다.\n     * @param {boolean} isResize 리사이즈 여부\n     */\n    draw(isResize) {\n      /**\n       * 모든 div제거\n       */\n      if (!isResize) {\n        Utils.removeAllChildren(viewerContainer);\n      }\n      /**\n       * 양면페이지인지 여부\n       */\n      const isDual =\n        currentPageMode === PageMode.DUAL ||\n        currentPageMode === PageMode.FIRST_DUAL;\n      /**\n       * for문 회전 단계\n       */\n      const step = fileType == FileType.EPUB ? 1 : isDual ? 2 : 1;\n\n      let processCount = 0;\n      /**\n       * Element를 생성하고 다시 계산해준다.\n       * @param {number} index\n       * @param {Function} creatorFunction HTML or 캔버스 생성함수\n       */\n      const createAndAppendElement = (index, creatorFunction) => {\n        if (fileType == FileType.EPUB) {\n          if (!isResize) {\n            const div = Builder.createRenderingDiv(index);\n            viewerContainer.appendChild(div);\n\n            creatorFunction(index, ({ doc, link, spaceTag }) => {\n              const shadowRoot = div.attachShadow({ mode: 'open' });\n\n              shadowRoot.appendChild(link);\n              shadowRoot.appendChild(doc);\n              if (currentPageMode != PageMode.SCROLL) {\n                shadowRoot.appendChild(spaceTag);\n              }\n\n              /**\n               * 페이지 클릭이벤트\n               */\n              shadowRoot.addEventListener('click', e => {\n                e.preventDefault();\n                const target = e.target;\n                if (target.href) {\n                  let linkUrl = Utils.replaceOriginUrl(target.href, '');\n                  const [path, hash] = linkUrl.split('#');\n                  if (!path && hash) {\n                    // console.log('aside?');\n                  } else {\n                    Navi.gotoHref(target.href);\n                  }\n                } else {\n                  /**\n                   * parent로 이벤트 전파\n                   */\n                  return;\n                }\n                e.stopPropagation();\n              });\n              this.resizeElement(div);\n              processCount += step;\n              if (total === processCount) {\n                /**\n                 * 모든 컨텐츠 스타일이 적용완료됫나 확인\n                 */\n                this.applyStylesAndObserve(viewerContainer, currentPageMode)\n                  .then(rs => {\n                    this.checkPageDivide();\n                    Navi.gotoPage(currentFileNo);\n                    this.updateCurrentPosition();\n                  })\n                  .catch(err => {\n                    console.error('##err', err);\n                  });\n              }\n            });\n          } else {\n            for (\n              let index = 0;\n              index < viewerContainer.children.length;\n              index++\n            ) {\n              const element = viewerContainer.children[index];\n              this.resizeElement(element);\n              processCount += step;\n              if (total === processCount) {\n                this.applyStylesAndObserve(viewerContainer, currentPageMode)\n                  .then(rs => {\n                    this.checkPageDivide();\n                    Navi.gotoPage(currentFileNo);\n                    this.updateCurrentPosition();\n                  })\n                  .catch(err => {\n                    console.error('##err', err);\n                  });\n              }\n            }\n          }\n        } else {\n          const canvas = creatorFunction(index, _canvas => {\n            if (isResize) {\n              const _current = Number(_canvas.dataset.page);\n              Utils.replaceChildAtIndex(\n                viewerContainer.children[_current],\n                0,\n                _canvas,\n              );\n            }\n            this.resizeCanvas(_canvas);\n            processCount += step;\n            if (total === processCount) {\n              Navi.gotoPage(currentFileNo);\n            }\n          });\n\n          if (!isResize) {\n            const div = Builder.createRenderingDiv(index);\n            viewerContainer.appendChild(div);\n            div.appendChild(canvas);\n          }\n        }\n      };\n\n      for (let index = 0; index < total; index += step) {\n        if (fileType == FileType.COMIC) {\n          if (isDual) {\n            createAndAppendElement(index, Walker.createCanvasWithIndex2);\n          } else {\n            createAndAppendElement(index, Walker.createCanvasWithIndex);\n          }\n        } else if (fileType == FileType.PDF) {\n          if (isDual) {\n            createAndAppendElement(index, Walker.createCanvasWithIndexPDF);\n          } else {\n            createAndAppendElement(index, Walker.createCanvasWithIndexPDF);\n          }\n        } else if (fileType == FileType.EPUB) {\n          createAndAppendElement(index, Walker.createHtmlWithIndex);\n        }\n      }\n    },\n\n    /**\n     * 현재 페이지 업데이트\n     */\n    updateCurrentPosition() {\n      const data = Utils.highestVisibleId(\n        viewerContainer,\n        currentPageMode == PageMode.SCROLL,\n      );\n      if (!data) {\n        return;\n      }\n      if (!data.element) {\n        return;\n      }\n      const _currentFileNo = Number(data.element.dataset.page);\n      this.updatePosition(_currentFileNo);\n    },\n    /**\n     * 현재 페이지로 업데이트\n     * @param {number} _currentFileno 페이지 번호\n     */\n    updatePosition(_currentFileno) {\n      /**\n       * 전체 사이즈 업데이트\n       */\n      this.updateCurrentTotalSize();\n      /**\n       * EPUB일때 페이지번호만 갱신\n       * COMIC,PDF일땐 파일번호로 표기\n       */\n      if (currentFileNo != _currentFileno) {\n        currentFileNo = _currentFileno;\n\n        if (fileType != FileType.EPUB) {\n          if (currentPageSpan.dataset.currentpage != currentFileNo) {\n            currentPageSpan.textContent = currentFileNo + 1;\n            currentPageSpan.dataset.currentpage = currentFileNo;\n          }\n          sliderRangeInput.value = currentFileNo;\n        }\n      }\n\n      // EPUB 현재페이지 갱신\n      this.updateCurrentEpubPage();\n    },\n    /**\n     * EPUB 현재페이지 갱신\n     */\n    updateCurrentEpubPage: () => {\n      if (fileType != FileType.EPUB) {\n        return;\n      }\n      /**\n       * 현제 페이지 업데이트\n       */\n      const pageObj = pageMap.get(currentFileNo);\n      if (!pageObj) {\n        return;\n      }\n      const parentPos =\n        currentPageMode == PageMode.SCROLL\n          ? viewerContainer.scrollTop\n          : viewerContainer.scrollLeft;\n      let findIndex = 0;\n      for (findIndex = 0; findIndex < pageObj.pageList.length; findIndex++) {\n        const it = pageObj.pageList[findIndex];\n        if (it.position >= parentPos) {\n          break;\n        }\n      }\n      const page = pageObj.pageList[findIndex];\n      if (!page) {\n        return;\n      }\n\n      const pageNumber = page.pageNumber;\n      if (currentPageSpan.dataset.currentpage != pageNumber) {\n        currentPageSpan.textContent = pageNumber + 1;\n        currentPageSpan.dataset.currentpage = currentFileNo;\n      }\n      currentEpubPage = pageNumber;\n      sliderRangeInput.value = pageNumber;\n    },\n    /**\n     * 전체페이지 업데이트\n     */\n    updateCurrentTotalSize: () => {\n      const totalSize = fileType === FileType.EPUB ? totalPageCount : total;\n      if (totalPagesSpan.dataset.currentpage != totalSize) {\n        totalPagesSpan.textContent = totalSize;\n        totalPagesSpan.dataset.currentpage = totalSize;\n        updateSlider(totalSize);\n      }\n    },\n  });\n\n  /**\n   * @class\n   * 이동 관련 클래스\n   */\n  const Navi = {\n    /**\n     * 특정 페이지로 이동\n     * @param {number} fileno\n     */\n    gotoPage(fileno) {\n      const isDual =\n        currentPageMode == PageMode.DUAL ||\n        currentPageMode == PageMode.FIRST_DUAL;\n      const movePage = isDual\n        ? fileno % 2 == 0\n          ? fileno\n          : fileno - 1\n        : fileno;\n\n      if (fileType == FileType.EPUB) {\n        const item = Position.findPage(pageMap, movePage);\n        if (!item) {\n          console.log('movePage', movePage, '없음');\n          return false;\n        }\n        const move =\n          currentPageMode == PageMode.SCROLL\n            ? {\n                top: item.position,\n                left: 0,\n              }\n            : {\n                top: 0,\n                left: item.position,\n              };\n        viewerContainer.scrollTo(move);\n        return true;\n      } else {\n        const child = Array.from(viewerContainer.children).find(\n          ele => ele.dataset.page == movePage,\n        );\n        if (!child) {\n          return false;\n        }\n        const childRect = child.getBoundingClientRect();\n        const parentRect = viewerContainer.getBoundingClientRect();\n\n        // Scroll positions\n        const offsetTop =\n          childRect.top - parentRect.top + viewerContainer.scrollTop;\n        const offsetLeft =\n          childRect.left - parentRect.left + viewerContainer.scrollLeft;\n\n        viewerContainer.scrollTo({\n          top: offsetTop,\n          left: offsetLeft,\n        });\n        return true;\n      }\n    },\n    /**\n     * 다음 페이지로 이동\n     */\n    gotoNextPage() {\n      const isDual =\n        currentPageMode == PageMode.DUAL ||\n        currentPageMode == PageMode.FIRST_DUAL;\n      const add = isDual ? 2 : 1;\n\n      let fileno = fileType == FileType.EPUB ? currentEpubPage : currentFileNo;\n      fileno += add;\n      const movePage = isDual\n        ? fileno % 2 == 0\n          ? fileno\n          : fileno - 1\n        : fileno;\n      this.gotoPage(movePage);\n    },\n    /**\n     * 이전 페이지로 이동\n     */\n    gotoPrevPage() {\n      const isDual =\n        currentPageMode == PageMode.DUAL ||\n        currentPageMode == PageMode.FIRST_DUAL;\n      const add = isDual ? 2 : 1;\n      let fileno = fileType == FileType.EPUB ? currentEpubPage : currentFileNo;\n      fileno -= add;\n      const movePage = isDual\n        ? fileno % 2 == 0\n          ? fileno\n          : fileno - 1\n        : fileno;\n      this.gotoPage(movePage);\n    },\n    /**\n     * atag href로 이동\n     * @param {string} href 아이디 혹은 주소 , 형식 -> 파일#이동아이디\n     */\n    gotoHref(href) {\n      console.log('##href', href);\n      // 미리 계산해둔 map에서 해당 position을 찾는다.\n      const range = Position.findPositionInHref(pageMap, href);\n      if (!range) {\n        // range 발견못함!\n        return;\n      }\n      const isDual =\n        currentPageMode == PageMode.DUAL ||\n        currentPageMode == PageMode.FIRST_DUAL;\n\n      // 양면 + 홀수 케이스엔 무조건 짝수 페이지로 이동해야 하기 때문에 짝수로 보정해준다.\n      const movePage = isDual\n        ? range.currentPage % 2 != 0\n          ? range.currentPage - 1\n          : range.currentPage\n        : range.currentPage;\n      // 이동!\n      Navi.gotoPage(movePage);\n    },\n  };\n\n  const Position = {\n    /**\n     * 페이지번호로 객체 찾기\n     * @param {number} page\n     * @returns\n     */\n    findPage(map, page) {\n      for (const [key, value] of map) {\n        for (const it of value.pageList) {\n          if (it.pageNumber === page) {\n            return it; // Return the matching object\n          }\n        }\n      }\n      return null; // Return null if no match is found\n    },\n    /**\n     * position으로 해당 객체 찾기\n     * @param {Map} map\n     * @param {number} position\n     * @returns\n     */\n    findPositionInRange(map, position) {\n      for (const [key, value] of map) {\n        const { pageList } = value;\n\n        for (let i = 0; i < pageList.length - 1; i++) {\n          const current = pageList[i];\n          const next = pageList[i + 1];\n\n          // position이 현재와 다음 사이에 존재하는지 확인\n          if (position >= current.position && position < next.position) {\n            return {\n              key,\n              page: value.page,\n              currentPage: current.pageNumber,\n              nextPage: next.pageNumber,\n            };\n          }\n        }\n      }\n\n      // 해당하는 position이 없는 경우\n      return null;\n    },\n    /**\n     * Href로 position 찾기\n     * @param {Map} map\n     * @param {string} href\n     * @returns\n     */\n    findPositionInHref(map, href) {\n      if (!(map instanceof Map)) {\n        throw Error('it is not the correct type');\n      }\n      if (typeof href != 'string') {\n        throw Error('it is not the correct type');\n      }\n      if (!href) {\n        throw Error('it is empty href');\n      }\n\n      let linkUrl = Utils.replaceOriginUrl(href, '');\n      const [path, hash] = linkUrl.split('#');\n      const replacePath = path.replace('/', '');\n\n      const file = viewerContainer.querySelector(`[data-src='${replacePath}']`);\n      if (!file) {\n        // 파일 발견못함!\n        return;\n      }\n      const hashElement = file.shadowRoot.querySelector('#' + hash);\n      if (!hashElement) {\n        // 파일 엘리먼트 발견못함!\n        return;\n      }\n\n      const { left, top } = hashElement.getBoundingClientRect();\n      //이동하려는 element의 offset\n      const pos = currentPageMode == PageMode.SCROLL ? top : left;\n      // 현재 스크롤위치\n      const parentPos =\n        currentPageMode == PageMode.SCROLL\n          ? viewerContainer.scrollTop\n          : viewerContainer.scrollLeft;\n      // 두개를 합친값이 이동하려는 scrollPosition\n      const targetPos = pos + parentPos;\n      // 미리 계산해둔 map에서 해당 position을 찾는다.\n      const range = Position.findPositionInRange(map, targetPos);\n      if (!range) {\n        // range 발견못함!\n        return;\n      }\n      return range;\n    },\n  };\n\n  /**\n   * @class\n   * 기타 유틸..\n   *\n   */\n  const Utils = {\n    /**\n     * 하위 child Element를 순차적으로 제거한다.\n     * @param {HTMLElement} parentElement\n     * @returns\n     */\n    removeAllChildren(parentElement) {\n      if (!parentElement) {\n        return;\n      }\n      while (parentElement.firstChild) {\n        parentElement.removeChild(parentElement.firstChild);\n      }\n    },\n    /**\n     * 스크롤내 보이는 child Element가 실제로 보여지는 퍼센트\n     * @param {HTMLElement} ulElement\n     * @param {boolean} overflowY 스크롤 방향\n     * @returns\n     */\n    calculateVisiblePercentages(ulElement, overflowY) {\n      const ulRect = ulElement.getBoundingClientRect();\n      const liElements = ulElement.children;\n      return Array.from(liElements).map(li => {\n        const liRect = li.getBoundingClientRect();\n        if (!overflowY) {\n          // 가시 영역의 너비 계산 (X 방향)\n          const visibleWidth =\n            Math.min(liRect.right, ulRect.right) -\n            Math.max(liRect.left, ulRect.left);\n          const percentage =\n            visibleWidth > 0 ? (visibleWidth / liRect.width) * 100 : 0;\n\n          return {\n            element: li,\n            percentage: Math.min(Math.max(percentage, 0), 100), // 퍼센트 클램핑 (0 ~ 100)\n          };\n        }\n        const visibleHeight =\n          Math.min(liRect.bottom, ulRect.bottom) -\n          Math.max(liRect.top, ulRect.top);\n        const percentage =\n          visibleHeight > 0 ? (visibleHeight / liRect.height) * 100 : 0;\n        return {\n          element: li,\n          percentage: Math.min(Math.max(percentage, 0), 100), // 퍼센트 클램핑 (0 ~ 100)\n        };\n      });\n    },\n    /**\n     * 스크롤내 보이는 child Element중 가장 많이 보여지는 객체를 찾는다\n     * @param {HTMLElement} ulElement\n     * @param {boolean} overflowY 스크롤 방향\n     * @returns\n     */\n    highestVisibleId(ulElement, overflowY) {\n      const ratio = this.calculateVisiblePercentages(ulElement, overflowY);\n      const highest = ratio.reduce(\n        (max, current) => {\n          return current.percentage > max.percentage ? current : max;\n        },\n        { element: null, percentage: 0 },\n      );\n      return highest;\n    },\n    /**\n     * 기존 자식 Element를 대체 Element로 교체한다.\n     * @param {HTMLElement} parent\n     * @param {number} index\n     * @param {HTMLElement} newElement\n     */\n    replaceChildAtIndex(parent, index, newElement) {\n      // 기존 자식 가져오기\n      const oldChild = parent.children[index];\n\n      // 기존 자식이 있으면 제거\n      if (oldChild) {\n        parent.removeChild(oldChild);\n      }\n\n      // 특정 위치에 새로운 요소 삽입\n      if (index < parent.children.length) {\n        parent.insertBefore(newElement, parent.children[index]);\n      } else {\n        // 자식이 없는 경우 맨 뒤에 추가\n        parent.appendChild(newElement);\n      }\n    },\n    /**\n     *\n     * @param {string} str\n     */\n    replaceOriginUrl(str, replaceStr) {\n      if (typeof str == 'string') {\n        const checkReplace = str.replace(window.location.href, replaceStr);\n        if (checkReplace.startsWith('#')) {\n          return checkReplace;\n        }\n        const list = window.location.href.split('/');\n        list.pop();\n        const locationHref = list.join('/');\n        const repResult = str.replace(locationHref, replaceStr);\n        if (repResult.startsWith('http')) {\n          const repResult2 = str.replace(window.location.href, replaceStr);\n          return repResult2;\n        }\n        return repResult;\n      }\n      return str;\n    },\n    /**\n     * epub root에 맞는 경로를 만들어준다.\n     * @param {*} str\n     * @returns\n     */\n    replaceEpubPathUrl(str) {\n      return this.replaceOriginUrl(str, epubRootDir);\n    },\n  };\n\n  /**\n   * @class\n   * 파일 핸들링을 위한 객체\n   *\n   */\n  const FileHandler = {\n    imageExtensions: /\\.(jpg|jpeg|png|gif|bmp|webp)$/i,\n    imageThumnail: /thum/i,\n\n    /**\n     * ZIP 파일을 가져와서 파일 경로 목록과 ZIP 객체 반환\n     * @param {string} zipUrl 파일 URL\n     * @returns {Promise<ExtractZip>}\n     */\n    async fetchAndExtractZipPaths(zipUrl) {\n      try {\n        // Fetch the ZIP file\n        const response = await fetch(zipUrl);\n        if (!response.ok) {\n          throw new Error(`Failed to fetch ZIP: ${response.statusText}`);\n        }\n        const blob = await response.blob();\n\n        // Use JSZip to extract the ZIP file\n        const jszip = new JSZip();\n        const zip = await jszip.loadAsync(blob);\n\n        // Collect file paths\n        const paths = [];\n        zip.forEach((relativePath, file) => {\n          console.log('#relativePath', relativePath);\n          paths.push({\n            src: relativePath,\n            file: file,\n            isDirectory: file.dir,\n            isImage: this.imageExtensions.test(relativePath),\n            isThumbnail: this.imageThumnail.test(relativePath),\n          });\n        });\n\n        return { zip, paths };\n      } catch (error) {\n        console.error('Error fetching or extracting ZIP file:', error);\n        throw error;\n      }\n    },\n\n    /**\n     * ZIP 객체에서 특정 파일을 Blob으로 추출\n     */\n    async getFileFromZip(zipObject, src, type = 'blob', isWithSrc, index) {\n      try {\n        const file = zipObject.file(src);\n        if (!file) {\n          throw new Error(`File \"${src}\" not found in the ZIP archive.`);\n        }\n        const blob = await file.async(type);\n        if (isWithSrc) {\n          return { blob, src, index };\n        } else {\n          return blob;\n        }\n      } catch (error) {\n        console.error('Error extracting file from ZIP:', error);\n        throw error;\n      }\n    },\n\n    /**\n     * ZIP 객체에서 특정 파일을 URL로 추출\n     */\n    async getFileUrlFromZip(zipObject, src) {\n      try {\n        const file = zipObject.file(src);\n        if (!file) {\n          throw new Error(`File \"${src}\" not found in the ZIP archive.`);\n        }\n        const blob = await file.async('blob');\n        const imgUrl = URL.createObjectURL(blob);\n        return imgUrl;\n      } catch (error) {\n        console.error('Error extracting file from ZIP:', error);\n        throw error;\n      }\n    },\n  };\n\n  /**\n   *\n   * @class\n   * XML 파서 , Epub에서 주로사용\n   *\n   */\n  const XmlToJsonConverter = {\n    // Function to process the key names\n    processKey: function (key) {\n      // Remove everything up to and including the last special character, and keep only the last character\n      const processedKey = key.replace(/[^a-zA-Z0-9]+([^a-zA-Z0-9]*)$/, '$1');\n      return processedKey;\n    },\n\n    // Function to convert XML to JSON\n    xmlToJson: function (xml) {\n      const obj = {};\n\n      // If the node has attributes, process them\n      if (xml.nodeType === 1) {\n        // element node\n        if (xml.attributes.length > 0) {\n          obj['@attributes'] = {};\n          for (let i = 0; i < xml.attributes.length; i++) {\n            const attribute = xml.attributes.item(i);\n            // obj['@attributes'][attribute.nodeName] = attribute.nodeValue;\n            obj['@attributes'][this.processKey(attribute.nodeName)] =\n              attribute.nodeValue;\n          }\n        }\n      }\n\n      // If the node has child nodes, process them\n      if (xml.hasChildNodes()) {\n        for (let i = 0; i < xml.childNodes.length; i++) {\n          const item = xml.childNodes.item(i);\n          const nodeName = this.processKey(item.nodeName);\n          if (obj[nodeName] === undefined) {\n            obj[nodeName] = this.xmlToJson(item);\n          } else {\n            if (Array.isArray(obj[nodeName])) {\n              obj[nodeName].push(this.xmlToJson(item));\n            } else {\n              obj[nodeName] = [obj[nodeName], this.xmlToJson(item)];\n            }\n          }\n        }\n      } else {\n        obj['#text'] = xml.nodeValue;\n      }\n\n      return obj;\n    },\n\n    // Function to parse and convert the XML string\n    convertXmlToJson: function (xmlString) {\n      const parser = new DOMParser();\n      const xmlDoc = parser.parseFromString(xmlString, 'application/xml');\n      return this.xmlToJson(xmlDoc);\n    },\n    /**\n     *\n     * @param {Array} itemrefArray\n     * @param {Array} itemArray\n     * @returns {Array}\n     */\n    matchItemrefToItem: (itemrefArray, itemArray) => {\n      return itemrefArray.map(ref => {\n        const matchedItem = itemArray.find(\n          item => item['@attributes'].id === ref['@attributes'].idref,\n        );\n        if (matchedItem) {\n          return {\n            href: matchedItem['@attributes'].href,\n            id: matchedItem['@attributes'].id,\n            'media-type': matchedItem['@attributes']['media-type'],\n            ...ref['@attributes'],\n          };\n        }\n      });\n    },\n    /**\n     * 파일경로에서 full-path에 해당되는 경로를 찾아 리턴한다.\n     * @param {string} src 파일경로\n     * @returns\n     */\n    getRootDir: src => {\n      return FileHandler.getFileFromZip(zipObject, src, 'string').then(\n        containerStr => {\n          const jsonResult = XmlToJsonConverter.convertXmlToJson(containerStr);\n          // Extract the full-path\n          const fullPath =\n            jsonResult.container.rootfiles.rootfile['@attributes']['full-path'];\n\n          const rootDir = fullPath.split('/')[0];\n\n          return rootDir;\n        },\n      );\n    },\n    /**\n     * 빈object,array를 제거시켜주는 정제작업함수\n     * @param {*} obj\n     * @returns\n     */\n    removeEmptyObjects(obj) {\n      if (typeof obj === 'object' && obj !== null) {\n        // Check if it's an array or an object and iterate over its properties\n        for (let key in obj) {\n          if (obj.hasOwnProperty(key)) {\n            if (typeof obj[key] === 'object') {\n              // Recursively remove empty objects\n              obj[key] = this.removeEmptyObjects(obj[key]);\n            }\n\n            // If the value is an empty string or only whitespace, delete the property\n            if (typeof obj[key] === 'string' && obj[key].trim() === '') {\n              delete obj[key];\n            }\n\n            // If the value is an empty array, delete the property\n            if (Array.isArray(obj[key]) && obj[key].length === 0) {\n              delete obj[key];\n            }\n            // If the value is an empty array, delete the property\n            if (Array.isArray(obj[key])) {\n              const isEmptyList = obj[key].filter(it => it);\n              if (isEmptyList.length == 0) {\n                delete obj[key];\n              }\n            }\n          }\n        }\n\n        // After cleaning, check if the object itself is empty\n        if (Object.keys(obj).length === 0) {\n          return null; // If the object is empty, return null to remove it\n        }\n      }\n      return obj;\n    },\n    /**\n     * 목차 navPoint를 파싱한다.\n     * @param {*} navPoints\n     * @param {*} depth\n     * @returns\n     */\n    parseNavPoint(navPoints, depth = 0) {\n      const parsedData = [];\n\n      // navPoints가 배열인 경우, 각 요소에 대해 처리\n      if (Array.isArray(navPoints)) {\n        navPoints.forEach(navPoint => {\n          const data = {};\n\n          // navLabel의 text 파싱\n          if (\n            navPoint.navLabel &&\n            navPoint.navLabel.text &&\n            navPoint.navLabel.text['#text']\n          ) {\n            data.navLabel = navPoint.navLabel.text['#text']['#text'];\n          }\n\n          // content의 src 파싱\n          if (\n            navPoint.content &&\n            navPoint.content['@attributes'] &&\n            navPoint.content['@attributes'].src\n          ) {\n            data.src = navPoint.content['@attributes'].src;\n          }\n\n          // depth 값 추가\n          data.depth = depth;\n\n          // 현재 파싱된 데이터 추가\n          parsedData.push(data);\n\n          // 재귀적으로 navPoint가 존재하는 경우 추가로 처리\n          if (navPoint.navPoint) {\n            const nestedData = this.parseNavPoint(navPoint.navPoint, depth + 1); // depth를 1 증가시켜 재귀 호출\n            parsedData.push(...nestedData); // 결과를 기존 데이터에 병합\n          }\n        });\n      }\n\n      return parsedData;\n    },\n    findNavMapObject(input) {\n      // 배열일 경우 각 요소를 순회\n      if (Array.isArray(input)) {\n        for (let i = 0; i < input.length; i++) {\n          const result = this.findNavMapObject(input[i]);\n          if (result) return result; // navMap이 있는 객체를 찾으면 반환\n        }\n      }\n\n      // 객체일 경우\n      if (input && typeof input === 'object') {\n        if (input.hasOwnProperty('navMap')) {\n          return input; // navMap 키가 존재하는 객체 반환\n        }\n\n        // 객체의 모든 키를 순회하여 재귀적으로 탐색\n        for (const key in input) {\n          if (input.hasOwnProperty(key)) {\n            const result = this.findNavMapObject(input[key]);\n            if (result) return result; // navMap이 있는 객체를 찾으면 반환\n          }\n        }\n      }\n\n      return null; // navMap이 존재하는 객체가 없으면 null 반환\n    },\n    /**\n     * 목차 파싱\n     * @param {string} tocSrc 목차 경로\n     * @returns\n     */\n    parseToc(tocSrc) {\n      return new Promise((resolve, reject) => {\n        FileHandler.getFileFromZip(zipObject, tocSrc, 'string')\n          .then(xmlString => {\n            const jsonResult = this.convertXmlToJson(xmlString);\n            const parseResult = this.removeEmptyObjects(jsonResult);\n            const has = this.findNavMapObject(parseResult.ncx);\n\n            const navs = this.parseNavPoint([has.navMap.navPoint], 0);\n            resolve(navs);\n          })\n          .catch(err => {\n            reject(err);\n          });\n      });\n    },\n    /**\n     * OPF XML을 해석해서 object로 돌려준다.\n     * @param {string} opfSrc OPF 파일경로\n     * @returns\n     */\n    parseOPF(opfSrc) {\n      return new Promise((resolve, reject) => {\n        FileHandler.getFileFromZip(zipObject, opfSrc, 'string')\n          .then(xmlString => {\n            /**\n             * xmlString을 해석\n             */\n            const jsonResult = this.convertXmlToJson(xmlString);\n            const packageObj = jsonResult.package;\n            const result = this.matchItemrefToItem(\n              packageObj.spine.itemref,\n              packageObj.manifest.item,\n            );\n            const result2 = result.map(it => {\n              it.hrefOrigin = it.href;\n              it.href = [...epubRootDir.split('/'), ...it.href.split('/')].join(\n                '/',\n              );\n              return it;\n            });\n            resolve(result2);\n          })\n          .catch(err => {\n            reject(err);\n          });\n      });\n    },\n  };\n  /**\n   *\n   *  EVENT\n   *\n   */\n  addEventListenerRegist(document, 'click', event => {\n    // console.log('#event.target', event.target);\n    // event.target.closest()\n    /**\n     * 사이드바를 누르면 유지\n     */\n    if (event.target.closest('#sideBar')) {\n      return;\n    }\n    /**\n     * 사이드 바가 올라와 있으면 숨김\n     */\n    if (!sideBar.classList.contains('hidden')) {\n      sideBar.classList.toggle('hidden');\n      return;\n    }\n    /**\n     * 상하 navbar toggle\n     * 메인 레이어 이벤트일 경우\n     */\n    if (event.target.closest('.content')) {\n      View.toggleNav();\n    }\n  });\n\n  /**\n   * tab button\n   */\n  addEventListenerRegist(tabButtons, 'click', e => {\n    tabButtons.forEach(btn => btn.classList.remove('active'));\n    e.target.classList.add('active');\n    panels.forEach(panel => panel.classList.remove('active'));\n    const tabId = e.target.dataset.tab;\n    document.getElementById(tabId).classList.add('active');\n  });\n  /**\n   * setting button\n   */\n  addEventListenerRegist(settingButton, 'click', e => {});\n  /**\n   * bottom menu button\n   */\n  addEventListenerRegist(bottomMenuButton, 'click', e => {\n    sideBar.classList.toggle('hidden');\n  });\n  /**\n   * 단면\n   */\n  addEventListenerRegist(pageModeSingleButton, 'click', e => {\n    View.setPageMode(pageModeSingleButton.dataset.pagemode);\n  });\n  /**\n   * 양면\n   */\n  addEventListenerRegist(pageModeDualButton, 'click', e => {\n    View.setPageMode(pageModeDualButton.dataset.pagemode);\n  });\n  /**\n   * 첫페이지 양면\n   */\n  addEventListenerRegist(pageModeDualFirstButton, 'click', e => {\n    View.setPageMode(pageModeDualFirstButton.dataset.pagemode);\n  });\n  /**\n   * 스크롤 모드\n   */\n  addEventListenerRegist(pageModeScrollButton, 'click', e => {\n    View.setPageMode(pageModeScrollButton.dataset.pagemode);\n  });\n  /**\n   * input변경\n   */\n  addEventListenerRegist(sliderRangeInput, 'input', e => {\n    //    const slidePage = Math.floor(sliderRangeInput.value);\n    // //    View.updatePosition(slidePage);\n  });\n  /**\n   * input 놨을때\n   */\n  addEventListenerRegist(sliderRangeInput, 'change', e => {\n    const slidePage = Math.floor(sliderRangeInput.value);\n    Navi.gotoPage(slidePage);\n  });\n  /**\n   * 이전 버튼\n   */\n  addEventListenerRegist(prevButton, 'click', e => {\n    Navi.gotoPrevPage();\n  });\n  /**\n   * 다음 버튼\n   */\n  addEventListenerRegist(nextButton, 'click', e => {\n    Navi.gotoNextPage();\n  });\n\n  /**\n   * 파일타입 변경\n   */\n  addEventListenerRegist(\n    [fileTypeEpubButton, fileTypePdfButton, fileTypeComicButton],\n    'click',\n    e => {\n      const f = e.target.dataset.filetype;\n      fileType = f;\n      init();\n      // console.log(f);\n    },\n  );\n  /**\n   * 키컨트롤\n   */\n  addEventListenerRegist(document, 'keydown', event => {\n    const allowedKeys = [\n      'Escape', // Esc\n      'ArrowRight', // →\n      'ArrowLeft', // ←\n      'ArrowUp', // ↑\n      'ArrowDown', // ↓\n      'c', // Ctrl+C\n      'v', // Ctrl+V\n      ' ',\n      'r',\n      ,\n      'i',\n      'Enter',\n    ];\n\n    const isCtrlKey = event.ctrlKey && (event.key === 'c' || event.key === 'v');\n\n    if (!allowedKeys.includes(event.key) && !isCtrlKey) {\n      // event.preventDefault(); // 기본 동작 막기\n    } else {\n      if (\n        event.key == 'ArrowRight' ||\n        event.key == 'ArrowDown'\n        // event.key == ' '\n      ) {\n        Navi.gotoNextPage();\n      } else if (event.key == 'ArrowLeft' || event.key == 'ArrowUp') {\n        Navi.gotoPrevPage();\n      } else if (event.key == 'Escape') {\n      }\n    }\n  });\n\n  // Prevent default behavior (Prevent file from being opened in the browser)\n  document.addEventListener('dragover', e => {\n    e.preventDefault();\n    e.stopPropagation();\n    // dropZone.style.backgroundColor = '#e0e0e0';  // Optional: change color when dragging over\n  });\n\n  document.addEventListener('dragleave', () => {\n    // dropZone.style.backgroundColor = '';  // Revert to original color\n  });\n\n  document.addEventListener('drop', e => {\n    e.preventDefault();\n    e.stopPropagation();\n    // dropZone.style.backgroundColor = '';  // Revert to original color\n\n    // Get the dropped files\n    const files = e.dataTransfer.files;\n\n    if (files.length > 0) {\n      const file = files[0];\n      const fileName = file.name;\n      const fileExtension = fileName.split('.').pop();\n      const expectedType = fileExtension.toLocaleLowerCase();\n      const fileBlob = new Blob([file], { type: file.type });\n      const blobUrl = URL.createObjectURL(fileBlob);\n      init(blobUrl, expectedType);\n    } else {\n      console.log('No files were dropped');\n    }\n  });\n\n  INSTANCE.PageMode = PageMode;\n  INSTANCE.FileType = FileType;\n\n  init();\n\n  return INSTANCE;\n};\n\n/* harmony default export */ const common = ((/* unused pure expression or super */ null && (Viewer)));\n\n;// ./src/viewer/index.js\n\n\n\n//# sourceURL=webpack://viewer-preview/./src/viewer/index.js_+_4_modules?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The require scope
/******/ 	var __webpack_require__ = {};
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript && document.currentScript.tagName.toUpperCase() === 'SCRIPT')
/******/ 				scriptUrl = document.currentScript.src;
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) {
/******/ 					var i = scripts.length - 1;
/******/ 					while (i > -1 && (!scriptUrl || !/^http(s?):/.test(scriptUrl))) scriptUrl = scripts[i--].src;
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__[29](0, __webpack_exports__, __webpack_require__);
/******/ 	
/******/ })()
;